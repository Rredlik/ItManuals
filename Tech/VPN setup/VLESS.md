# Установка VPN (Proxy) на сервере

Итак, вы купили VPS у хостера и вам пришли логин и пароль от него. Что я советую сделать сразу после установки:

- [Настройка сервера](../../Os/Linux/Ubuntu)

- Сменить пароль пользователя root с изначального на ваш уникальный.
  ```
  passwd root
  ```
  Не использовать учетную запись root, а создать непривелигированного пользователя командой adduser и назначить ей сложный пароль командой passwd <username>.
  ```
  adduser <username>
  ```
  ```
  sudo adduser <username> sudo
  ```
  > Чтобы отключить необходимость ввода пароля для команд sudo, необходимо изменить файл:
  > ```
  > sudo nano /etc/sudoers
  > ```
  > Найти в нем строку includedir /etc/sudoers.d и под ней написать
  > ```
  > username ALL=(ALL) NOPASSWD:ALL
  > ```
  Когда вы убедитесь, что новая учетка работает, стоит запретить вход для root‑юзера по SSH, выставив (раскомментировав) в «no» или «prohibit‑password» опцию PermitRootLogin в файле /etc/ssh/sshd_config
  ```
  nano /etc/ssh/sshd_config
  ```
  После изменения необходимо перезапустить службу sshd:
  ```
  systemctl restart sshd
  ```


- Перевесить SSH со стандартного порта 22 на нестандартный порт (например, на 54 321, 41 467, выберите любой рандомный выше 1000). Это особенно важно для маскировки XTLS‑Reality. Порт задается опцией «Port» в том же /etc/ssh/sshd_config (но если у вас Ubuntu 22.10 и новее, то там все сложнее)
  ```
  apt install net-tools
  netstat -tulpan | grep 22
  ```
  Видим, что порт 22 занят. Проверим 2233:
  ```
  netstat -tulpan | grep 2233
  ```
  Вывод пуст, можно занимать. Меняем порт в конфигурационном файле SSH сервера, воспользоваться можно любым текстовым редактором:
  ```
  nano /etc/ssh/sshd_config
  ```
  Ищем строку "Port 22". Если строка начинается с символа #, его нужно удалить, и вместо 22 порта написать любой другой, например, 2233. Сохраняем изменения. Перезапускаем SSH
  ```
  systemctl restart ssh
  ```
  Так как текущая сессия SSH ещё активна, можно открыть новое окно и проверить, что подключение по новому порту работает:
  ```
  ssh username@ip_address -p2233
  ```
  Проверяем:
  ```
  netstat -tulpan | grep ssh
  ```
  Если все нормально, увидим похожий результат:
  ```
  tcp        0      0 *:2233                  *:*                     LISTEN      3849/sshd       

  tcp6       0      0 [::]:2233               [::]:*                  LISTEN      3849/sshd
  ```
  

- Обновите версии пакетов в системе на свежие, в Debian и Ubuntu это делается командами apt update и apt upgrade.
  ```
  apt update
  apt upgrade
  ```

## Устанавливаем XRay на сервере
Разработчики XRay разработали скрипт, который автоматически загружает XRay для вашей операционной системы и создает systemd‑юнит для его запуска: [ссылка на скрипт](https://github.com/XTLS/Xray-install). 
Установить его можно таким образом:
```shell
apt install curl mc htop nano
bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install
```
```
systemctl stop xray.service
```
Или вы можете установить XRay вручную. Для этого переходим по [ссылке](https://github.com/XTLS/Xray-core/releases) на последний релиз XRay-core и скачиваем самую свежую версию:
```
wget https://github.com/XTLS/Xray-core/releases/download/v1.8.9/Xray-linux-64.zip
```
Создаем каталог, распаковываем и делаем исполняемым файл (поскольку он поставляется в архиве .zip, права доступа могут быть потеряны при распаковке):
```
mkdir /opt/xray
unzip ./Xray-linux-64.zip -d /opt/xray
chmod +x /opt/xray/xray
```
Это позволит процессу открывать сокеты на привилегированных портах в частности (443) без необходимости запуска всего процесса от имени (root):
```
setcap cap_net_bind_service=+ep /opt/xray/xray
```
Создаёт нового пользователя «xrayuser» без домашнего каталога и доступа к оболочке (bash), от которого будет запускаться юнит
```
sudo adduser --shell /usr/sbin/nologin --no-create-home xrayuser
```
Затем создаем systemd-юнит (nano /usr/lib/systemd/system/xray.service) и вставляем в него следующий текст
```
[Unit]
Description=Xray Service
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=xrayuser
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /usr/local/etc/xray/config.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
```
или
```
[Unit]
Description=XRay
[Service]
Type=simple
Restart=on-failure
RestartSec=30
WorkingDirectory=/opt/xray
ExecStart=/opt/xray/xray run -c /opt/xray/config.json
[Install]
WantedBy=multi-user.target
```

Активируем:
```
systemctl daemon-reload
systemctl enable xray
```
Единственное отличие при использовании скрипта заключается в том, что файлы конфигурации XRay будут храниться не в /opt/xray, а в /usr/local/etc/xray/.


## Настройка

Домен microsoft.com указан для примера, можно и нужно заменить на что‑то своё. Крайне рекомендуется воспользоваться [этим](https://github.com/XTLS/RealiTLScanner) для нахождения подходящего домена для маскировки. Основное требование — поддержка TLSv1.3. Лучше всего выбирать сайт физически хостящийся в стране вашего сервера.

Любую из них можно запихнуть в QR в виде plain текста, большинство клиентов умеют их импортировать.

## Настройка VLESS c XTLS-Reality

Сначала нужно определиться, под какой сайт вы будете маскироваться.

Вариант раз: это должно быть какой‑то очень популярный иностранный сайт, желательно не связанный с политикой и СМИ, не относящийся к «нежелательным организациям», и к которому наврядли возникнут вопросы со стороны органов РФ (например, youtube.com — довольно плохой выбор в этом плане, есть шанс блокировки в будущем). Просто попробуйте вспомнить какой‑нибудь ресурс, которым пользуются много людей и компаний, который цензоры до последнего не будет блокировать без большой нужды, чтобы не разломать пол‑интернета (и нет, это не гугл). Предлагать варианты тут не буду, пусть каждый выберет какой‑то свой. И да, не обязательно использовать главный домент сайта, можно брать какие‑то из поддоменов.

Выбрав домен, проверяем, что он подходит под наши критерии командой curl. Например, для www.microsoft.com команда будет выглядеть так:

```
curl -v -L --tlsv1.3 --http2 https://www.microsoft.com
```
Если в ответ вы видите много логов и HTML-код, то все хорошо, должно работать. Если в ответ вы получаете какую-то ошибку, то стоит попробовать поискать другой домен для маскировки.
Вариант два: поищите какие-нибудь не слишком популярные сайты (к ним меньше внимания) в сети того же хостинга, что и ваш сервер. Для этого существует [утилита](https://github.com/XTLS/RealiTLScanner), скачать готовый экзешник можно там со страницы Releases.

Важно отметить тот факт, что XTLS‑Reality имеет недостаток — если сайт, под который вы маскируетесь, испытывает технические проблемы (например, временно отключил TLSv1.3), или огородился от вашего сервера (устав от проксируемых запросов на установление соединений), или попал под блокировку, то точно так же перестанет работать и ваш прокси. В этом случае совершенно нормально будет поменять используемый маскировочный домен на какой‑то другой. Мы потом еще настроим на сервере Shadowsocks и SSH как запасной вариант на случай проблем, а пока продолжаем с настройкой VLESS.

Вам нужно будет сгенерировать несколько параметров следующими командами:
```
./usr/local/bin/xray uuid
openssl rand -base64 16
./usr/local/bin/xray x25519
openssl rand -hex 8
```
Тут внимательно. Приватный ключ используется только в конфиге на сервере, публичный ключ же наоборот, в конфиге сервера не упоминается, зато его должны будут знать все клиенты вашего прокси. Сохраните оба ключа в надежное место.

После этого нужно подготовить конфиг‑файл. Итак, приводим (редактором nano или как вам удобнее) файл /opt/xray/config.json (или /usr/local/etc/xray/config.json если ставили скриптом) к следущему виду:
```shell
nano /opt/xray/config.json
```
Пример конфига:
```
{
    "log": {
        "loglevel": "info"
    },
    "inbounds": [
        {
            "listen": "IP_адрес_вашего_сервера",
            "port": 443,
            "protocol": "vless",
            "tag": "reality-in",
            "settings": {
                "clients": [
                    {
                        "id": "сюда вставить ID из выхлопа ./usr/local/bin/xray uuid",
                        "email": "user@server",
                        "flow": "xtls-rprx-vision"
                    }
                ],
                "decryption": "none"
            }
        },
        {
            "port": 42639,
            "tag": "ss",
            "protocol": "shadowsocks",
            "settings": {
                "method": "2022-blake3-aes-128-gcm",
                "password": "сюда вставить выхлоп команды openssl rand -base64 16",
                "network": "tcp,udp"
            }
        },
        {
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "dest": "ваш_маскировочный_домен:443",
                    "xver": 0,
                    "serverNames": [
                        "ваш_маскировочный_домен"
                    ],
                    "privateKey": "сюда вставить приватный ключ из выхлопа ./usr/local/bin/xray x25519",
                    "minClientVer": "",
                    "maxClientVer": "",
                    "maxTimeDiff": 0,
                    "shortIds": [
                        "сюда вставить выхлоп команды openssl rand -hex 8"
                    ]
                }
            },
            "sniffing": {
                "enabled": true,
                "destOverride": [
                    "http",
                    "tls",
                    "quic"
                ]
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom",
            "tag": "direct"
        },
        {
            "protocol": "blackhole",
            "tag": "block"
        }
    ],
    "routing": {
        "rules": [
            {
                "type": "field",
                "protocol": "bittorrent",
                "outboundTag": "block"
            }
        ],
        "domainStrategy": "IPIfNonMatch"
    }
}
```
Файл состоит из нескольких секций. Первая — log, определяет настройки логгирования (мы ставим уровень info). Вторая, «inbounds», определяет, какие протоколы и с какими параметрами будут исползоватся для входящих подключений на прокси. Третья, «outbounds», описывает, куда может пойти трафик с вашего прокси, там указаны «freedom» (выход в чистый интернет), «blackhole» (если надо не пускать пользователя куда‑то) и «dns» (встроенный dns‑сервер). Последний «routing» определяет дополнительные правила, что и куда мы будем перенаправлять, например, подключения по протоколу Bittorrent блокируем, отправляя в blackhole, чтобы ваши пользователи не создали вам проблем, раздавая гигабайты через ваш сервер (если не надо можете удалить эти строки из конфига). Все остальное отправляется в свободный интернет (по умолчанию).

Перезапустите XRay командой 
```
systemctl restart xray
```
Сразу после этого можно проверить что все нормально командой (должно быть написано active (running))
```
systemctl status xray
```
Если он не запускается или что-то идет не так, то можно посмотреть сообщения об ошибках и логи командой
```
journalctl -u xray
```

Теперь нам надо собрать ссылку для клиента, котрая будет выглядеть так:
```
vless://ваш_UUID@IP_адрес_вашего_сервера:443/?encryption=none&type=tcp&sni=домен_сайта&fp=chrome&security=reality&alpn=h2&flow=xtls-rprx-vision&pbk=ваш_публичный_ключ&packetEncoding=xudp
```
Соответственно, вместо ваш_UUID подставляете UUID, дальше после собаки — IPv4 адрес вашего сервера, домен_сайта -фейковый домен, под который вы маскируете, ваш_публичный_ключ — публичый ключ, который вы сгенерировали выше, а в конце после символа # можно написать название вашего сервера, которое увидит пользователь (латинскими буквами, без пробелов).

Эту ссылку можно вставлять в разные клиенты (чаще всего допускается вставка из буфера обмена), и из нее автоматически создатся подключение в клиенте. Можете делиться этой ссылкой со своими родными и друзьями. На мобильных клиентах часто есть функция сканирования QR‑кода камерой, в таком случае из этой ссылки можно сгенерировать QR‑код любым онлайновым генератором кодов и использовать его.

Если что‑то не работает, ссылку всегда можно вставить в клиент типа Nekray/Nekobox (и под Android тоже), и проверить, все ли там правильно, каждый параметр по‑отдельности.


Цитата из статьи MiraclePtr:
> Сделайте проброс порта не только на 443/TCP-порт (его делает XTLS-Reality), а еще на 443/UDP и 80/TCP до сервера, под который вы маскируетесь. Например, если вы маскируетесь под www.microsoft.com, то отрезолвте его IP-адрес (с помощью nslookup, ping или какого-нибудь онлайн-сервиса), а потом добавьте правила iptables (можно засунуть в /etc/rc.local, если он у вас есть - см. инструкции для вашего Linux-дистрибутива):
> ```
> iptables -t nat -A PREROUTING -i eth0 -p udp --dport 443 -j DNAT --to-destination fake_site_ip:443
> ```
> ```
> iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination fake_site_ip:80
> ```
>(вместо eth0 должен быть ваш сетевой интерфейс, иногда бывает ens3, например).

 ## Клиенты
Самый красивый и простой в настройке: Hiddify‑Next. Работает под Windows, Linux, macOS, под Android, в разработке версия под iOS. Скачать бинарник под вашу десктопную систему или.apk‑файл для Android можно на [странице проекта](https://github.com/hiddify/hiddify-app/releases).


## Дополнительно

Меняем timezone:
```
timedatectl set-timezone Europe/Amsterdam
```
